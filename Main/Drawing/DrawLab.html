<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DrawLab</title>
<style>
    body {
        margin: 0;
        font-family: "Segoe UI", sans-serif;
        display: flex;
        flex-direction: column;
        height: 100vh;
        background: #0a0a0a;
        color: #fff;
    }

    /* --- Top Toolbar --- */
    #topbar {
        background: rgba(0, 0, 0, 0.95);
        border-bottom: 2px solid #ff0000;
        box-shadow: 0 0 10px #ff0000;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        padding: 6px;
        gap: 8px;
        z-index: 10;
    }
    #topbar label {
        font-size: 14px;
        color: #ff4d4d;
    }
    #topbar button, #topbar select, #topbar input {
        background: #111;
        border: 1px solid #ff0000;
        color: #ff4d4d;
        border-radius: 5px;
        padding: 6px 10px;
        font-size: 14px;
        cursor: pointer;
        flex-shrink: 0;
    }
    #topbar button:hover, #topbar select:hover, #topbar input:hover {
        background: #ff0000;
        color: #fff;
        box-shadow: 0 0 6px #ff0000;
    }

    /* --- Main Layout --- */
    #main {
        flex: 1;
        display: flex;
        overflow: hidden;
        position: relative;
    }

    /* Sidebar */
    #sidebar {
        background: rgba(0, 0, 0, 0.95);
        border-right: 2px solid #ff0000;
        box-shadow: 0 0 10px #ff0000;
        width: 220px;
        display: flex;
        flex-direction: column;
        padding: 12px;
        box-sizing: border-box;
        transition: transform 0.3s ease;
        z-index: 5;
    }
    #sidebar h2 {
        text-align: center;
        font-size: 16px;
        margin-bottom: 12px;
        color: #ff0000;
        text-shadow: 0 0 8px #ff0000;
    }
    #sidebar button, #sidebar input {
        margin-bottom: 10px;
        padding: 8px;
        border-radius: 6px;
        background: #111;
        border: 1px solid #ff0000;
        color: #ff4d4d;
        cursor: pointer;
    }
    #sidebar button:hover {
        background: #ff0000;
        color: #fff;
    }

    /* Canvas stack */
    #canvasContainer {
        flex: 1;
        position: relative;
    }
    canvas {
        position: absolute;
        top: 0; left: 0;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
    }
    #gridCanvas {
        pointer-events: none; /* grid overlay only */
    }

    /* --- Mobile adjustments --- */
    @media (max-width: 768px) {
        #sidebar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            transform: translateX(-100%);
            z-index: 20;
        }
        #sidebar.active {
            transform: translateX(0);
        }
        #toggleSidebar {
            display: inline-block;
        }
    }
    @media (min-width: 769px) {
        #toggleSidebar {
            display: none;
        }
    }

    /* --- Footer watermark --- */
    #watermark {
        position: fixed;
        bottom: 6px;
        right: 10px;
        font-size: 12px;
        color: white;
        opacity: 0.8;
        pointer-events: none; /* can't be clicked */
        font-style: italic;
    }
</style>
</head>
<body>

<!-- Top bar -->
<div id="topbar">
    <button id="toggleSidebar">☰ Menu</button>
    <button id="undo">Undo</button>
    <button id="redo">Redo</button>
    <label>Brush:</label>
    <select id="brushType">
        <option value="pen">Pen</option>
        <option value="soft">Soft Brush</option>
        <option value="neon">Neon Pen</option>
        <option value="eraser">Eraser</option>
    </select>
    <label>Size:</label>
    <input type="number" id="sizePicker" min="1" max="50" value="5">
    <label>Color:</label>
    <input type="color" id="colorWheel" value="#ff0000">
    <button id="toggleGrid">Grid</button>
</div>

<!-- Main area -->
<div id="main">
    <div id="sidebar">
        <h2>⚡ Tools</h2>
        <button id="clear">Clear</button>
        <button id="download">Download</button>
        <label>Add Image</label>
        <input type="file" id="imageLoader" accept="image/*">
    </div>
    <div id="canvasContainer">
        <canvas id="drawingCanvas"></canvas>
        <canvas id="gridCanvas"></canvas>
    </div>
</div>

<!-- Watermark -->
<div id="watermark">Made by Glitched Override</div>

<script>
const canvas = document.getElementById('drawingCanvas');
const ctx = canvas.getContext('2d');
const gridCanvas = document.getElementById('gridCanvas');
const gridCtx = gridCanvas.getContext('2d');
const sidebar = document.getElementById('sidebar');
const topbar = document.getElementById('topbar');
const toggleSidebar = document.getElementById('toggleSidebar');

let drawing = false;
let brushColor = document.getElementById('colorWheel').value;
let brushSize = parseInt(document.getElementById('sizePicker').value);
let brushType = "pen";
let gridEnabled = false;
let lastX = 0, lastY = 0;
let history = [];
let redoStack = [];

// Resize & keep content
function resizeCanvas() {
    const data = canvas.toDataURL();
    canvas.width = gridCanvas.width = window.innerWidth - (sidebar.offsetWidth || 0);
    canvas.height = gridCanvas.height = window.innerHeight - topbar.offsetHeight;
    const img = new Image();
    img.src = data;
    img.onload = () => ctx.drawImage(img, 0, 0);
    if (gridEnabled) drawGrid();
    else gridCtx.clearRect(0,0,gridCanvas.width,gridCanvas.height);
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Save state for undo
function saveState() {
    history.push(canvas.toDataURL());
    if (history.length > 50) history.shift();
    redoStack = [];
}
saveState();

function undo() {
    if (history.length > 1) {
        redoStack.push(history.pop());
        let img = new Image();
        img.src = history[history.length - 1];
        img.onload = () => {
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.drawImage(img,0,0);
        };
    }
}
function redo() {
    if (redoStack.length > 0) {
        let data = redoStack.pop();
        history.push(data);
        let img = new Image();
        img.src = data;
        img.onload = () => {
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.drawImage(img,0,0);
        };
    }
}

// Drawing logic
function startDrawing(x,y) {
    drawing = true;
    lastX = x;
    lastY = y;
    if (gridEnabled) fillGrid(x,y);
}
function drawLine(x,y) {
    if (!drawing) return;
    if (gridEnabled) {
        fillGrid(x,y);
        return;
    }

    ctx.lineCap = "round";
    ctx.lineWidth = brushSize;

    if (brushType === "eraser") {
        ctx.globalCompositeOperation = "destination-out"; // true erase
    } else {
        ctx.globalCompositeOperation = "source-over"; // normal
        ctx.strokeStyle = brushColor;
    }

    if (brushType === "soft") {
        ctx.globalAlpha = 0.6;
        ctx.shadowBlur = 0;
    } else if (brushType === "neon") {
        ctx.globalAlpha = 1;
        ctx.shadowBlur = brushSize * 1.2;
        ctx.shadowColor = brushColor;
    } else {
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
    }

    ctx.beginPath();
    ctx.moveTo(lastX,lastY);
    ctx.lineTo(x,y);
    ctx.stroke();

    lastX = x;
    lastY = y;
}
function stopDrawing() {
    if (drawing) saveState();
    drawing = false;
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.globalCompositeOperation = "source-over"; // reset
}

// Grid mode
function fillGrid(x,y) {
    const gridSize = 20;
    const gx = Math.floor(x / gridSize) * gridSize;
    const gy = Math.floor(y / gridSize) * gridSize;
    if (brushType === "eraser") {
        ctx.clearRect(gx, gy, gridSize, gridSize); // erase squares
    } else {
        ctx.fillStyle = brushColor;
        ctx.fillRect(gx, gy, gridSize, gridSize);
    }
}
function drawGrid() {
    const gridSize = 20;
    gridCtx.clearRect(0,0,gridCanvas.width,gridCanvas.height);
    gridCtx.strokeStyle = "rgba(255,0,0,0.3)";
    for (let x = 0; x < gridCanvas.width; x += gridSize) {
        gridCtx.beginPath();
        gridCtx.moveTo(x,0);
        gridCtx.lineTo(x,gridCanvas.height);
        gridCtx.stroke();
    }
    for (let y = 0; y < gridCanvas.height; y += gridSize) {
        gridCtx.beginPath();
        gridCtx.moveTo(0,y);
        gridCtx.lineTo(gridCanvas.width,y);
        gridCtx.stroke();
    }
}

// Mouse
canvas.addEventListener('mousedown', e => startDrawing(e.offsetX,e.offsetY));
canvas.addEventListener('mousemove', e => drawLine(e.offsetX,e.offsetY));
canvas.addEventListener('mouseup', stopDrawing);
canvas.addEventListener('mouseout', stopDrawing);

// Touch
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    startDrawing(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
});
canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    drawLine(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
});
canvas.addEventListener('touchend', stopDrawing);

// UI events
document.getElementById('colorWheel').addEventListener('input', e => brushColor = e.target.value);
document.getElementById('sizePicker').addEventListener('change', e => brushSize = parseInt(e.target.value));
document.getElementById('brushType').addEventListener('change', e => brushType = e.target.value);

document.getElementById('clear').addEventListener('click', () => {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    saveState();
});
document.getElementById('download').addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = "drawing.png";
    link.href = canvas.toDataURL("image/png");
    link.click();
});
document.getElementById('imageLoader').addEventListener('change', e => {
    const reader = new FileReader();
    reader.onload = function(event){
        const img = new Image();
        img.onload = function(){
            ctx.drawImage(img,0,0,canvas.width,canvas.height);
            saveState();
        }
        img.src = event.target.result;
    }
    reader.readAsDataURL(e.target.files[0]);
});
document.getElementById('toggleGrid').addEventListener('click', () => {
    gridEnabled = !gridEnabled;
    if (gridEnabled) drawGrid();
    else gridCtx.clearRect(0,0,gridCanvas.width,gridCanvas.height);
});
document.getElementById('undo').addEventListener('click', undo);
document.getElementById('redo').addEventListener('click', redo);

// Sidebar toggle (mobile)
toggleSidebar.addEventListener('click', () => {
    sidebar.classList.toggle("active");
});
</script>

</body>
</html>
